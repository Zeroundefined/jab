#! /bin/bash

. $JAB/bin/first_dir
. $JAB/colour-environ

# functons for git

_git_status_char_regexp="[ MADRCU]"
_git_status_regexp="^$_git_status_char_regexp$_git_status_char_regexp"
# sorted by strcmp of function name

# x

# xx

ga () {
    [[ -n $GIT_ADDED ]] && GIT_ADDED="$@" || GIT_ADDED="$GIT_ADDED:""$@"
    git add "$@"
}

gc () {
    local _storage=/tmp/gc.sh
	if [[ -z "$@" ]]; then git commit --verbose
	else
        python -c "print 'git commit -m\"$*\"'" > $_storage
        _show_run_storage
	fi
    GIT_ADDED=
}

gd () {
    git diff "$@"
}

gi () {
    git "$@"
}

gs () {
    shift_dir "$@" && shift
	_do_git_status $dir "$@"
}

tc () {
    v ~/.gitconfig
}

# xxx

gaa () {
    ga .
}

gac () {
    local addable=.
    if [[ -e $1 ]]; then
        addable=$1
        shift
    fi
    ga $addable && gc "$@"
}

gai () {
    ga --interactive "$@"
}

gcj () {
    local _storage=/tmp/gcj.sh
    local GIT="git -C $JAB"
	if [[ -z "$@" ]]; then $GIT commit --all --verbose
	else
        python -c "print '$GIT commit -m\"$*\"'" > $_storage
        _run_storage
	fi
}

gdi () {
    git di "$@"
}

gdv () {
    git dv "$@"
}

_gl () {
    local cmd=$1
    shift
    local loglines=$(( $LINES / 2 ))
    git $cmd "$@" | head -n $loglines
}

gla () {
    _gl lg --author=Alan.Brogan "$@"
}

glg () {
    _gl lg "$@" 
}

gln () {
    _gl lg --name-only "$@"
}

glt () {
    _gl lt "$@"
}

gpp () {
    grr "$@"
    gpu "$@"
}

_gp () {
    local stashed=
    if git_changed; then
        stashed=1
        git stash -q
    fi
    git "$@"
    if [[ $stashed == 1 ]]; then
        git stash pop -q
    fi
}

gpu () {
    _gp push "$@"
}

grr () {
    _gp pull --rebase "$@"
}

grs () {
    git rerere status
}

gsd () {
    shift_dir "$@" && shift
    for f in $(git -C $dir status -s | grep "^ M" | cut -dM -f2)
    do
        git dv $f     
    done
    STATUS_QUESTIONS=$(git -C $dir status -s | grep "??" | cut -d' ' -f2)
    [[ -n $STATUS_QUESTIONS ]] && v $STATUS_QUESTIONS
}

_gsi_opt () {
    local red='\[\033[0;31m\]'
    red="\033[0;31m"
    local no_colour='\[\033[0m\]'
    no_colour="\033[0m"
    GSI_MENU="${GSI_MENU}${red}${1}${no_colour}${2}${suffix}"
}

_gsi_menu () {
    GSI_MENU=
    suffix=", "
    _gsi_opt q uit
    _gsi_opt a dd
    _git_modified $1 && _gsi_opt s plit
    _gsi_opt d rop
    [[ -n $GIT_ADDED ]] &&_gsi_opt f asten
    _gsi_opt v im
    suffix=";"
    _gsi_opt hjkl " move"
    echo -n -e "$(_status_chars $1) $1: $GSI_MENU"
}

_gsi_prompt () {
    _gsi_menu $1
    read -e -n1 -p " " answer
}

gsi () {
    shift_dir "$@" || shift
    for f in $(git -C $dir status -s | grep "^\( M\|??\)" | sed -e "s/^...//")
    do
        [[ -z $f ]] && continue
        _git_modified $f && git di $f || (_git_untracked $f && cat $f || continue)
        _gsi_prompt $f
        if [[ $answer =~ [fF] ]]; then gc; _gsi_prompt $f; fi
        [[ $answer =~ [qQ] ]] && break
        [[ $answer =~ [aA] ]] && ga $f
        [[ $answer =~ [sS] ]] && (_git_modified $f && gai $f || (_git_untracked $f && echo Cannot split untracked file))
        [[ $answer =~ [dD] ]] && (_git_modified $f && git co $f || (_git_untracked $f && rm -i $f))
        [[ $answer =~ [vV] ]] && v $f
    done
    [[ -n $GIT_ADDED ]] && gc
    [[ -n $STATUS_QUESTIONS ]] && vimcat $STATUS_QUESTIONS
}

gsv () {
    shift_dir "$@" || shift
    for f in $(git -C $dir status -s)
    do
        if echo $f | grep -q "^ M" ;then
            git dv $(echo $f | cut -dM -f2)
        elif echo $f | grep -q "^ A"; then
            vim  $(echo $f | cut -dM -f2)
        fi
    done
}

# xxxx

gaic () {
    gai .; gc "$@"
}

# xxxxx
# xxxxxx
# xxxxxxx

_do_git_stat () {
	local __doc__="get the short status from git"
    reuse_dir "$@" && shift
	if shift_path "$@"; then
        git -C $dir status -s "$path" 2 > /dev/null
	else echo \"$path\" is not a file
	fi
}

_show_git_here () {
    [[ -d $PWD/.git ]] || return
    local days=${1:-5}
    local _log=$(git -C $PWD log -n 1)
    [[ $? ]] && git -C $PWD lg --since="$days days ago"
}

# xxxxxxxxxx

# xxxxxxxxxxx

git_changed () {
    git_dir=${1:-$PWD}
    [[ -d $git_dir/.git ]] || return 1
    git -C $git_dir status --porcelain | gre -q "$_git_status_regexp"
}

# xxxxxxxxxxxx

_git_modified () {
    [[ $(_status_chars $1) == " M" ]]
}

_run_storage () {
    bash $_storage
    rq $_storage
}

# xxxxxxxxxxxxx

_git_untracked () {
    [[ $(_status_chars $1) == "??" ]]
}

_status_chars () {
    git -C $dir status -s -- $1 | sed -e "s/\(..\).*/\1/"
}

_do_git_status () {
	local __doc__="get the status from git"
    dir=$1; shift
	[[ -z $dir ]] && dir=$PWD
	# [[ -d ${dir}/.git ]] || return
    git -C $dir status "$@"
}

# xxxxxxxxxxxxxx

show_git_time () {
    git_dir=${1:-$PWD}
    [[ -d $git_dir/.git ]] || return
    local _log=
    local period=
    local lines_left=$(( $LINES / 2 ))
    for period in seconds minutes hours days weeks "month | grep -v year" year
    do
        regexp=$period.ago
        _log=$(_get_git_timer $regexp)
        if [[ -n $_log ]]; then
            period_lines=$(_get_git_timer $regexp | wc -l)
            _get_git_timer $regexp | head -n $lines_left
            [[ $period_lines -gt $lines_left ]] && break
            lines_left=$(( lines_left - $period_lines ))
        fi
    done
}

# xxxxxxxxxxxxxxx

_any_git_changes () {
	local __doc__="whether the current dir has modified or untacked files"
    local dir=$1
	[[ -z $dir ]] && dir=$PWD
	if [[ -d ${dir}/.git ]]; then
        git -C $dir status --porcelain | gre "$_git_status_regexp"
    fi
}

_get_git_timer () {
    git -C $git_dir lg 2> /dev/null | grep $1 | head -n $(( $LINES / 2 ))
}

_has_git_changes () {
    local dir=$1
    local _files=$(_any_git_changes $dir)
    [[ -n $_files ]]
}

# xxxxxxxxxxxxxxxxx

git_simple_status () {
    _has_git_changes $1 || return
    local git_dir=$dir
    [[ -n $1 ]] && git_dir=$1
    _do_git_stat $git_dir
    # | grep "$_git_status_regexp"
}

_show_run_storage () {
    cat $_storage
    _run_storage
}

