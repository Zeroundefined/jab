The argv module
==================

    >>> import argv

The module provides helper functions to make options
    which can be used to create an optparse.OptionParser

Making the parser
-----------------

Options are made from a list of tuples
    with at least a name and a help string
    >>> help_string = 'Default is %default'

A tuple can also add
    default value, short name and action
If you do not supply these they will be:
    an empty string
    initial of the full name
    appropriate to type of the default

Usually add() is called with the tuples (e.g. each module imported calls it)
    >>> argv.add_options( [ ('welcome',help_string,'Fred'), ])

Then call parse_args() once, e.g. in main()
    (Not doing that here - do not know what is on command line)

    options, args = argv.parse_args()

Or, you could get it to parse a specific command line

    >>> options, args = argv.parse_args('Hello')
    >>> print ' '.join(args + [ options.welcome ])
    Hello Fred
    >>> options, args = argv.parse_args('Hello -w World')
    >>> print ' '.join(args + [ options.welcome ])
    Hello World

The module retains the last options, args which it parsed 
    >>> args == argv.args and options == argv.options
    True

The module will catch any files or directories in the command line
    >>> argv.test_args('-w alan $JAB ~/.bashrc $JAB/vim/vimrc fred /usr')
    >>> print argv.files[0], argv.files[1]
    /.../.bashrc /.../vim/vimrc
    >>> print argv.directories[0], argv.directories[1]
    /...jab /usr

Many scripts act on the first directory you give them
    This is separated out as well
    >>> argv.first_directory == argv.directories[0]
    True

If you didn't give any directories on command line, it defaults to here
    >>> argv.test_args('-w alan fred')
    >>> argv.first_directory == test.here
    True

Most of the time: that's it.

Post processing options
-----------------------

You can write a method to process args after the OptionParser has made them
    It should take in an options, args tuple, and return the same
    >>> def changer(options, args):
    ...     options.welcome = 'Martin'
    ...     return options, args + [ 'and' ]

    >>> def finisher(options, args):
    ...     options.welcome = 'Alan'
    ...     return options, args + [ 'Goodbye' ]

Add it on to the list of such processors
    >>> argv.post_parses.append( changer )
    >>> argv.post_parses.append( finisher )

These methods will be called from parse_args()  
    in the order they were added (so Martin will disappear)
Test with the same command line as before
    >>> options, args = argv.parse_args('Hello -w World')
    >>> print ' '.join(args + [ options.welcome ])
    Hello and Goodbye Alan

Running the parser yourself
---------------------------

You could also get the parser and use it your way
    Note: we have already added a "welcome" option
        to which this list will be added
    >>> all = ( [
    ...     ('alan',help_string),
    ...     ('fred',help_string,'Fred'),
    ...     ('good',help_string,True),
    ...     ('ok',help_string,False,'y'),
    ...     ('bad',help_string,False,'n','store_false'),
    ...     ('exit',help_string,'quit','x'),
    ... ])
    >>> opt_parser = argv._make_parser(all)

That is a normal OptionParser
For example to show some help
    >>> print opt_parser.format_help().replace('Usage','usage').replace('Options','options')
    usage: argv.test [options]
    <BLANKLINE>
    options:
      -a ALAN, --alan=ALAN  Default is
      -f FRED, --fred=FRED  Default is Fred
      -g, --good             Default is True
      -y, --ok              Default is False
      -n, --bad              Default is False
      -x EXIT, --exit=EXIT  Default is quit
      -w WELCOME, --welcome=WELCOME
                            Default is Fred
      -h, --help            show this help message and exit

Or to parse an argv type list
    >>> opts, args = opt_parser.parse_args('fred -a brogan'.split())
    >>> print args[0]
    fred
    >>> show( opts.__dict__ )
    {'alan': 'brogan',
     'bad': False,
     'exit': 'quit',
     'fred': 'Fred',
     'good': True,
     'ok': False,
     'welcome': 'Fred'}

Flag options
------------

If the user includes a flag option it means "not the default value"
    Set your help text accordingly

In this example it seems
    -y has a default of False, so using it means "set true"
        so help text is "use this to turn on Y"
    -g has a default True, so using it means "set false"
        so help text is "use this to turn OFF G"
    -n also has default False, but set its action to "set false"
        so help text is "do not use this, it does nothing"

Nothing on the command line
    So these are the default values
    >>> opts, args = opt_parser.parse_args(''.split())
    >>> print opts.ok, opts.good, opts.bad
    False True False

Use all flag options - most values have changed
    But notice that using -n made no difference
    >>> opts, args = opt_parser.parse_args('-ygn'.split())
    >>> print opts.ok, opts.good, opts.bad
    True False False

Reset
-----
Do not interfere with other tests
    >>> argv.reset()
