#! /bin/bash
#
# Copyright Alan Brogan, 2011
#
# See LICENSE file for your rights
#
# This script manipulates the command line for vim
#	It checks for existence of a swap file for the file you want to edit
# 		It offers to recover the file before editting
#	 It expands file names
#		anything ending with a "." will have "py", "cpp" or "erl" added if the file exists

test -f debugging && set -x

#
# Default to using $EDITOR, if that is not available use "vim"
#	This script will not work with any other editor except vim
#	It prefers $EDITOR in case of multiple installations
#
editor=${EDITOR-vim}

JAB_TESTING=$JAB/python/testing
edit_testers ()
{
	arg=$JAB_TESTING/$1
	if [[ -z $TRACKER_TESTING && -n $TRACKERS ]]
	then TRACKER_TESTING=$TRACKERS/testing
	fi
	if [[ -n $TRACKER_TESTING && -d $TRACKER_TESTING ]]
	then
		POST_PROCESSING="rsync -q --exclude=.svn $JAB_TESTING/* $TRACKER_TESTING/"
	fi
}

# Finish file names "left short" by tab-completion
# For example, if an argument is "fred.", and no file called "fred." exists
#     but "fred.py" does exist, then we'll edit fred.py
#
# Files "left short" by tab-completion are those which would have same stem, but different extension
# So we will complete for "*.py", "*.cpp"
#
# Also replace any "fred.pyc" with "fred.py"
#
args=
for arg in $*
do
	arg=${arg/%.pyc/.py}
	if echo $arg | grep -q ^- 
	then
		args="$args $arg"
	elif [[ ! -f ${arg} && ${arg%%.} != $arg ]]
	then
		for ext in py cpp erl
		do 
			extended=${arg}${ext}
			if [[ -f $extended ]]
			then
				arg=$extended
				break
			fi
		done
		args="$args $arg"
	else
		if [[ `basename $arg` == "try.py" ]]
		then
			edit_testers try.py
		elif [[ `basename $arg` == "test_files.py" ]]
		then
			edit_testers test_files.py
		elif [[ `basename $arg` == "see.py" ]]
		then
			edit_testers see.py
		fi
		args="$args $arg"
	fi
done

# Recover any files which have corresponding swap files
safe=1
file_exists=0
for file in $args
do
	if [[ ${file#+} != $file || ${file#-} != $file ]] 
	then
		continue
	fi
	if [[ -e $file ]]
	then
		file_exists=1
	else
		path_file=$(which $file 2> /dev/null)
		if [[ -f $path_file ]]
		then file_exists=2
		fi
	fi
	cd `/usr/bin/dirname $file`
	base=`basename $file`
	export swap_file=`$editor -r 2>&1 | grep ^[0-9] | sed -e s/[0-9]\.\ *// -e s/.\$// | grep "\<$base\>"`
	cd - > /dev/null 2>&1
	swap_file=`/usr/bin/dirname $file`/$swap_file
	if [[ -f "$swap_file" ]]
	then
		echo
		echo    A swap \ file \ exists: $swap_file
		echo " ps a |  grep -v -e grep -e \"\<$$\>\"| grep -q \"\<vim.* $file\>\" "
		if ps a |  grep -v -e grep -e "\<$$\>"| grep -q "\<vim.* $file\>"
		then
			echo -n A process is running:\ 
			ps a |  grep -v -e grep -e "\<$$\>"| grep "\<vim.* $file\>" 
			echo
			echo It is not safe to run \"$editor $*\"
			safe=
		else
			read -p"Recover $args ? " reply
			if [[ -z $reply || $reply == "y" || $reply == "Y" ]]
			then
				echo Recovering $swap_file
				recovered_file="${file}.recovered"
				#
				# I use the "g:recovering" variable within vim to prevent opening of extra tabs, YMMV
				#
				$editor -r ${file} --cmd ":let g:recovering=1" -c"|:wq! ${recovered_file}" >/dev/null 2>&1
				/bin/rm -f $swap_file 
				if ! diff -q $file $recovered_file
				then
					$editor -d $file $recovered_file
				fi
				/bin/rm -f $recovered_file
			else
				safe=
			fi
			break
		fi
	else
		if [[ ! -d $file ]]
		then
			if ps a |  grep -v -e grep -e "\<$$\>"| grep -q "\<vim.* $file\>"
			then
				echo    No swap \ file \ exists
				echo -n A process is running:\ 
				ps a |  grep -v -e grep -e "\<$$\>"| grep "\<vim.* $file\>" 
				safe=
			fi
		fi
	fi
done

post_vimming ()
{
#
# This function is called after editting, arguments are same as vim got
#
	local arg
	for arg in $*
	do
		[[ -e $arg ]] && ls -l $arg
	done
	if [[ -n $POST_PROCESSING ]]
	then $( $POST_PROCESSING )
	fi
}

if [[ -f debugging ]]
then
	if [[ -z $safe ]]
	then
		echo It was not safe to run \"$editor $*\" anyway
	else
		echo "$editor $args"
	fi
else
	if [[ -z $safe ]]
	then
		echo It is not safe to run \"$editor $*\"
	else
		if [[ $file_exists == "0" ]]
		then 
			$editor $args
		elif [[ $file_exists == "2" ]]
		then
			prompt_path="$path_file"
		else
			prompt_path="$args"
		fi
		if [[ $file_exists != 0 ]]
		then
			read -p"$editor $prompt_path ? " reply
			if [[ -z $reply || $reply == "y" || $reply == "Y" ]]
			then
				$editor $prompt_path
			elif [[ $file_exists == "2" ]]
			then
				$editor $args
			fi
		fi
		post_vimming $args
	fi
fi
exit 0
